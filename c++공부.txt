<c++시작하기>

hello world출력 코드
#include <iostream>
int main(){
	std::cout << "Hello, world!" << std::endl;
	return 0;
}

c++에서 한 행 주석은  //를 사용하면 된다
ex) // 간단한 C++프로그램

c++에서 입출력을 포함한 많은 기본 기능은 기본 영역이 아닌 표준 라이브러리에 속해있다 
기본 영역에 속한 기능은 모든 C++프로그램에서 늘 사용할 수 있다 하지만 표준 라이브러리는 반드시 명시적으로
요쳥해야 사용할 수 있다
표준 라이브러리 기능을 요청할 떄는 #include 지시문을 사용한다 이러한 지시문은 일반적으로 프로그램 시작 부분에 등장한다
ex) #include <iostream>
iostream은 순차적 또는 연속적인 입출력을 지원한다 #include 지시문에서 iostream이 꺽쇠괄호(<, >)로 묶여 있을 떄는 표준 헤더라는
C++라이브러리 일부분을 참조한다 
C++ 표준에서는 각 헤더의 명칭과 동작을 정의하는데 그런데 표준 헤더가 무엇인지 정확하게 알려주지는 않는다
프로그램에 표준 헤더를 포함하면 관련 라이브러리 기능을 사용할 수 있다는 것만 알고 있으면 된다 

함수는 프로그램 일부분에 이름을 붙인 것으로서 프로그램의 다른 영역에서 호출하거나 실행할 수 있다 모든 C++프로그램은 반드시
main함수를 포함하며 C++구현체는 main함수를 호출해서 프로그램을 실행한다 

main함수는 프로그램이 성공적으로 실행되었는지 알릴려고 정수값을 반환한다 0이외의 값은 문제가 있음을 의미한다 
main함수 호출은  int main()이렇게 하고 여기서 int는 정수를 나타내려는 용도로 정의된 이름이다 main뒤의 괄호 안에는
함수가 실행되면서 받는 매개변수가 들어간다 매개변수가 없으면 괄호가 비어있다 

C++에서는 프로그램 실행 시 중괄호 사이의 내용을 하나의 단위로 취급한다 왼쪽 중괄호는 실행문의 시작을 표시하고 오른쪽 중괄호는
실행문의 끝을 표시한다 즉 중괄호는 그 사이에 있는 모든 실행문이 하나의 함수에 속해 있음을 나타낸다 
ex)int main(){// 왼쪽 중괄호   // 실행문 } // 오른쪽 중괄호 

표준 라이브러리를 사용한 출력
ex) std::cout << "hellow world!" << std::endl;
이 실행문은 표준 라이브러리의 출력 연산자인 <<를 사용하여 hello world를 출력하고 이어서 std::endl의 값을 출력한다
이름이 std::로 시작하는 코드는 해당 이름이 std라는 네임스페이스에 속해 있음을 나타낸다 
네임스페이스는 관련 있는 기능을 하나의 이름 아래 모아놓은 것이다 std는 표준 라이브러리가 정의한 모든 기능이 속한 네임스페이스다
예를들어 iostream 표준 헤더는 cout과 endl을 정의하며 이를 참조하려면 std::cout와 std::endl로 표기해야 한다 

std::cout은 표준 출력 스트림을 참조하는 이름이다 C++구현체에서 프로그램의 일반적인 출력 기능이 필요할 때 사용한다
GUI 기반 운영체제에서 이 실행문을 사용하면 프로그램과 연관된 창에 실행문에서 정한 내용을 출력한다 

표준 출력 스트림에 std::end을 넣으면 현재 행에서 더 어떤 내용을 출력하지 않는다 따라서 프로그램에서 추가로 생성하는
출력 내용은 새로운 행에 나타난다


반환문은 해당 함수의 실행을 끝내고 함수를 호출한 프로그램에 return과 세미콜론 사이의 값을 반환한다
반환 값은 함수가 반환할 것이라고 명시한 타입과 일치해야 한다 main함수의 경우 반환 타입이 int이고 반환 대상은
main함수를 호출한 C++구현체이다 즉 main함수의 반환문은 구현체로 전달할 정수값 표현식을 반드시 표현해야 한다 
프로그램 종료 지점이 여러 군데일 수도 있는데 이러한 프로그램은 여러 개의 반환문이 있을 수 있다 
함수 정의에서 해당 함수가 특정 타입의 값을 반환할 것이라 명시했다면 함수의 모든 반환문은 반드시 적합한 타입의 값을 반환해야 합니다


표현식은 프로그램에서 무언가를 계산하도록 요청한다 표현식을 실행했을 때는 부수적으로 발생하는 결과가 프로그램이나 구현체의 상태에
간접적으로 영향을 줄 수 있다 예를들어 3+4는 7을 반환하여 부수적으로 발생하는 결과가 텂지만
 std::cout << "hellow world!" << std::endl;과 같은 코드는 부수적으로 발생하는 결과로 표준 출력 스트림에 hello world를 넣는다
표현식은 연산자와 피연산자를 포함하며 형태가 다양하다  << 는 기호 연산자이고 std::cout, "hello world" std::endl는 피연산자이다
모든 피연산자는 타입이 있는데 데이터 구조와 해당 데이터 구조에 적합한 연산이 무엇인지 나타내는 것이다
연산자의 역할은 피연산자의 타입에 따라 달라진다 
타입에는 이름이 있는데 예를들어 프로그래밍 언어의 기본 영역은 정수를 표현하는 타입의 이름을 int라고 정의한다
그리고 라이브러리는 스트림 기반 출력을 제공하는 타입의 이름을 std::ostream이라고 정의한다 
std::cout는 std::ostream타입이다

<<연산자는 2개의 피연산자가 있다 예제에서 2개의 <<연산자와 3개의 피연산자를 볼 수 있는데 << 연산자에 왼쪽 우선 결합성이라는
성질이 있기 때문이다 쉽게 말해 하나의 표현식에 << 연산자가 두번 이상 나타날 때 각 << 연산자는 자신을 기준으로
왼쪽의 모든 부분과 오른쪽의 최소 부분을 피연산자로 사용한다 
예제에서 첫 번째 << 연산자의 오른쪽 피연산자는 Hello world이고 왼쪽 피연산자는 std::cout이고 두 번째 << 연산자의 오른쪽
피연산자는 std::endl 이고 왼쪽 피연산자는 std::cout << "Hello world"이다 
각 << 연산자는 피연산자의 타입에 따라 동작이 다르다 첫 번째 << 연산자는 std::ostream타입인 std::cout을 왼쪽 피연산자로 갖는다
그리고 알 수 없는 타입의 문자열 리터럴을 오른쪽 피연산자로 갖는다 << 는 왼쪽 피연산자에 해당하는 스트림에 오른쪽 피연산자의
문자들을 넣는다 그 결과는 다시 왼쪽 피연산자가 된다
따라서 두 번째 << 연산자의 왼쪽 피연산자는 std::ostream타입인 std::cout를 반환하는 표현식이고 오른쪽 피연산자는 조작어인 std::endl이다
스트림에 조작어를 넣으면 문자를 넣는 것과는 다른 동작을 실행함으로써 스트림을 조작한다 << 연산자의 왼쪽 피연산자가 std::ostream타입이고
오른쪽 피연산자가 조작어라면 << 연산자는 주어진 스트림에 관한 조작어의 동작을 실행하고 해당 스트림을 반환한다 std::endl이 실행하는
동작은 현재 행에서 출력을 마치는 것이다
결국 전체 표현식은 std:;cout을 값의 형태로 반환하고 부주적으로 발새하는 결과를 표준 출력 스트림에 helloworld를 넣고 현재 행의
출력을 끝낸다 표현식을 세미콜론으로 끝내면 표현식이 반환하는 값을 구현체가 무시하게 만든다 
이러한 동작이 적절한 경우는 표현식의 목적이 오로지 hello world를 출력하는 것이기 때문이다

범위는 해당 이름이 문맥적으로 유지되는 프로그램의 영역을 말한다 C++에는 여러 종류의 범위가 있으며 예제에서는 두 가지를 발견할 수 있다
첫 번째 범위는 네임스페이스이다 네임스페이스는 관련 있는 기능을 모아놓은 것인데 표준 라이브러리는 std라는 네임스페이스에 속한 모든 기능을
미리 정의한다 따라서 일부로 std를 정의하지 않는다면 std에 속한 기능들과 자체적으로 정의할 기능들이 충돌하는 일은 없다
표준 라이브러리가 정의한 기능을 사용한다면 해당 기능이 라이브러리에 속한 기능이라는 것을 명시해야 한다 예를들어
std::cout는 std라는 네임스페이스에 정의된 기능인 cout임을 의미한다

std::cout라는 이름은 정규화된 이름으로 ::연산자(범위연산자)를 사용한다 ::연산자는 왼쪽에는 범위의 이름이 있는데 std::cout의 경우
범위의 이름은 std라는 네임스페이스이다 :: 연산자는 오른쪽에는 왼쪽의 범위에서 정의한 이름이 있다 따라서
cout::cout는 네임스페이스 std범위에 있는 cout라는 이름을 의미한다 

두 번쨰 범위는 중괄호이다 main 함수를 포함한 모든 함수의 본문은 그 자체가 하나의 범위이다 


프로그램 구조
C++프로그램은 일반적으로 자유 형식이다 즉 인접한 기호들이 함께 실행되는것을 방지할 떄만 공백이 필요하다 
특히 행 바꿈은 공백의 한 종류이며 특별한 의미는 없다 프로그램에 공백을 두면 가독성이 훨씬 좋아져서
가독성을 높이기 위해 들여쓰기를 사용한다 
자유형식이 아닌 세 가지 독립 요소들은 다음과 같다
-문자열 리터럴(string literals): 큰따옴표로 묶인 문자들은 여러 행에 작성할 수 없다
-#include 이름 : 하나의 행으로 명시해야 한다 
- 주석(//) : // 이후에 오는 모든 내용이 주석이며 현재 행의 끝에서 끝난다 
(/*로 시작하는 주석은 자유 형식이며 짝을 이르는  */가 등장할 때까지 여러 행으로 작성할 수 있다)

타입 
데이터 구조 및 해당 데이터 구조의 연산을 정의한다 C++에는 크게 두 가지 종류의 타입이 있는데 
int처럼 프로그래밍 언어의 기본 영역 안에서 정의한 것과 std::ostream처럼 프로그래밍 언어의 기본 영역 밖에서 정의된 것이 있다

네임스페이스
관련 기능을 모아놓은 것이다 표준 라이브러리의 기능들은 std라는 네임스페이스에 정의된다 

문자열 리터럴
큰따옴표(")로 시작하고 끝난다 각 문자열의 리터럴은 행 하나에 완전히 표시되어야 한다 문자열 리터럴의 일부 문자는 앞에 역슬래시가
있을 떄 특별한 의미를 지닌다
- \n : 행 바꿈 문자
- \t : 탭 문자
- \b : 백스페이스 문자
- \" : 큰따옴표를 문자열의 경계가 아닌 문자열 일부로 취급
- \' : 문자열 리터럴과의 일관성을 위해 문자열 리터럴에서 '와 같은 의미로 취급
- \\ : \를 문자열일부로 취급하고 다음에 오는 문자를 일반 문자로 처리한다 

정의문과 헤더
C++프로그램이 사용하는 모든 기능은 저마다 정의문이 있다 표준 라이브러리는 헤더에 이름을 정의하며 프로그램은 #include를 지시문으로
헤더에 접근한다 그러므로 기능을 사용하기 전에 이름이  정의되어 있어야 한다 따라서 #include지시문은 헤더에 있는 기능을
사용하기 전에 먼저 등장해야 한다 

main함수
C++모든 프로그램은 int타입을 반환하는 main함수를 반드시 하나만 정의해야 한다 구현체는 main함수를 호출해서 프로그램을 시작한다
main함수에서 0을 반환하면 성공 0이아닌 값을 반환하면 실패를 나타낸다 일반적으로 모든 함수는 적어도 하나의 반환문을 포함해야하며
함수 끝에 도달한것이 함수 종룔를 의미하지는 않는다 예외로 main함수는 반환문을 생략할 수 있는데 이때 0을 반환한다고 가정한다

중괄호와 세미콜론
C++에서 아주 중요한 기호들이다 중괄호로 묶인 0개 이상의 연속된 실행문들을 블록이라 하며 각각 순서대로 실행된다
함수의 본문이 단 1개의 실행문으로 구성되더라도 중괄호로 묶여야 한다 중괄호 안의 실행문들은 하나의 범위를 구성한다
세미콜론으로 끝나는 표현식을 실행문이다 이를 표현식으로 만든 실행문이라 한다 부수적으로 발생하는 결과를 얻기 위해 표현식을
사용하는것이며 표현식이 반환하는 결과는 무시한다 실행문에 표현식을 사용하는것은 선택 사항이며 이를 생략해 세미콜론만
남겨두면 아무 효과가 없는null문이 된다 


</c++시작하기>


<문자열사용>

입력한 내용을 전달받으려면 이를 저장할 장소가 있어야 한다 그러한 장소를 변수라고 하고 변수는 이름이 있는 객체이다 
객체는 타입이 정해진 컴퓨터 메모리의 일부이다 객체와 변수의 구분은 중요한데 이름없는 객체가 존재하기 떄문이다

변수를 사용하려면 구현체에 변수 이름과 타입을 알려줘야 한다 변수 이름과 타입을 모두 지정하면 구현체는 프로그램의 기계
코드를 더 효율적으로 만든다 또한 컴파일러가 변수 이름 중에서 오탈자를 탐지할 수 있다 
std::string name; 와 같이 변수를 선언 했을 때 변수 이름은 name이고 타입은 std::string이다 
std::뒤에 오는 이름 string은 프로그래밍 언어의 기본 영역이 아닌 표준 라이브러리의 일부라는 뜻이다 
std::string과 관련된 헤더인 <string>을 #include지시문에 추가해줘야 한다 

함수 안에서 변수를 선언하면 변수는 함수 중괄호 안에서만 존재하는 지역변수가 된다 
컴퓨터가 '}'에 도달하면 변수는 소멸하고 변수가 차지하던 메모리를 반환한다 지역 변수의 수명이 제한적이므로 변수와 그 외의 객체를 구별하는 것이 중요하다

객체의 타입에는 인터페이스 개념이 포함되어 있다 인터페이스는 어떤 타입의 객체로 할 수 있는 동작들의 모음이다 예를들어
문자열 변수 name의 정의문은 문자열(string)에서 사용할 수 있는 모든 라이브러리를 name에서 다룰 것임을 암묵적으로
언급한 것이다 그리고 name동작 중 하나는 문자열을 초기화 하는 것이 있다 

문자열 변수를 정의하면 암묵적으로 변수가 초기화된다 왜냐하면 표준 라이브러리에서는 모든 문자열 객체가 값을 갖는다고 정해놓았기
떄문이다 원하는 값을 넣어 문자열을 만들 수 있지만 동작이 없다면 문자를 전혀 갖지 않는다 이러한 문자열을
빈 문자열 또는 null 문자열이라고 한다 

출력 시 << 연산자와 std::cout를 사용하는 것처럼 입력 시에는 >> 연산자와 std:;cin을 사용한다 
문자열을 읽도록 라이브러리에 요청하면 공백 문자(스페이스 , 탭, 백스페이스 행 바꿈)을 무시하고 다음 공백 문자나 EOF이 나타날때까지
문자들을 읽기 시작하여 변수에 넣는다  

일반적으로 입출력 라이브러리는 출력 작업을 최적화하려고 버퍼라는 내부 데이터 구조를 사용한다 각 출력 요청에
효율적으로 응답하려고 라이브러리는 버퍼를 사용하여 출력할 문자열을 모은다 그리고 필요할 때만 버퍼에 저장한 내용을
출력하고 버퍼를 지운다 이러한 방법으로 여려 번의 출력 작업을 효율적으로 처리한다 

시스템이 버퍼를 비우는 상황은 세 가지가 있는데 첫 번째는 버퍼가 가득 차 있으면 라이브러리는 자동으로 버퍼를 비우고
두 번쨰로 라이브러리가 표준 입력 스트림으로 입력 내용을 요청받으면 라이브러리는 버퍼가 가득 차기를 기다리지 않고
즉시 버퍼를 비운다 세 번쨰 개발자가 명시한 코드로 버퍼를 비울 수 있다 
std::endl값이 출력되면 이 행헤서 해야 할 작업이 끝나므로 버퍼를 지운다 이떄 시스템은 버퍼의 내용을 출력 스트림에 강제로 즉시 반영한다 
출력 버퍼를 적절한 순간에 비우는 것은 실행 시간이 긴 프로그램을 만들 떄 중요한 사항이다 프로그램의 일부 출력 내용을 버퍼에
저장한 후 출력장치로 보여지기 전까지 오랫동안 갇혀 있는 상황을 비효율적이기 때문이다 


변수는 정의하면서 변수에 값을 넣을 수 있다 변수의 이름과 세미콜론 사이에 = 기호와 변수에 넣을 값을 명시하면 된다 변수와 값이
서로 다른 타입이면 구현체는 넣은 값을 변수의 타입으로 변환한다
ex) std::string hello = "hello world!";

+기호를 사용하여 1개의 문자열과 1개의 문자열 리터럴을 결합하거나 2개의 문자열끼리 결합할 수 있다 2개의 문자열 리터럴 사이에는
기호를 사용한 결합 관계가 성립하지는 않는다 
숫자 사이의 + 기호와 문자열 사이에서 +기호의 의미는 완전히 다르게 된다 
연산자가 다양한 타입의 피연산자에 따라 다른 의미로 동작하는것을 연산자의 오버로드라고 한다 

상수를 정의할 때 const를 사용한다 상수는 값을 변경하지 않겠다는 약속이며 프로그램을 쉽게 이해하게 할떄 상수를 사용하면 좋다 
const로 정의한 값은 변경하지 못하므로 정의할 떄 반드시 초기화를 해야한다 

연산자의 의미가 달라져도 연산자의 결합성은 변하지 않는데 + 연산자, >> 연산자도 왼쪽 우선 결합성을 갖는다 

상수나 변수의 생성 방법은 타입에 따라 다르다 
std::string space(helloName.size(), ' '); 와 같이 생성한다고 했을 때 변수.size()는 멤버 함수를 호출하는 방법인다
helloName이라는 객체는 size라는 구성 요소가 있는데 이 구성요소는 함수이므로 값을 얻으려고 호출할 수 있다 
helloName은 std::string타입이며 helloName.size()로 변수의 문자 개수를 나타내는 정수를 얻을 수 있다 
여기서 ' ' 은 문자 리터럴이다 문자 리터럴은 문자열 리터럴과는 완전히 다른데 문자 리터럴은 항상 작은따옴표로 묶고 문자열
리터럴은 항상 큰따옴표로 묶는다 문자 리터럴은 기본 타입인 char이다 문자 리터럴은 단일 문자를 나타낸다
문자열 리터럴 안에서 특수한 의미가 있는 문자 리터럴에서도 같은 의미이다 따라서 '나 \은 앞에 \를 사용해서 써야한다 

문자 타입
-char : 구현체가 정의한 기본 타입이며 일반 문자를 저장한다
-wchar_t : 한국어 같은 언어의 문자를 표현할 만큼 크기가 큰 확장문자를 저장하는 기본 타입

문자열 타입
표준 헤더 <string>에 정의되어 있다 문자열 타입 객체는 0개 이상의 문자로 이루어진 순차열을 갖는다 
정수를 n 문자를 c 입력스트림을 is 출력스트림을 os라고 하면 문자열 연산의 종류는 다음과 같다 
-std::string s : std::string타입의 변수 s를 정의하며 변수s는 빈 문자열로 초기화된다
-std::string t : std::string타입의 변수 t를 정의하며 변수 t는 s에 있는 문자들의 복사본으로 초기화된다
-std::string z(n,c) : std::string 타입의 변수 z를 정의하며 변수 z는 문자 c의 복사본 n개를 포함하여 초기화된다 c는]
문자열 또는 문자열 리터럴이 아닌 char타입이어야 한다 
- os << s  : os가 가리키는 출력 스트림에 s에 포함된 문자들을 서식 변경 없이 출력한다 표현식 결과는 os이다 
-is >> s : 공백 외의 문자가 등장할때까지  is가 가리키는 스트림에서 문자들을 읽고 버린다 그 다음 is가 가리키는 스트림에서
새로운 공백이 등장할떄까지 연속된 문자들을 s로 읽어들인다 이때 기존의 s의 값이 무엇이든지 상관없이 덮어써진다
- s + t : 이 표현식의 결과는 s에 있는 문자들의 복사본과 t에 있는 문자들의 복사본을 결합한 std::string객체이다 
-s.size()  : s에 있는 문자들의 개수이다 

변수 
변수는 세 가지 방법 중 하나로 정의할 수 있다
1. std::string hello = "hello "; 초기값을 명시하여 변수를 정의
2. std::string stars(100, '*'); 타입과 주어진 표현식에 따라 변수를 생성 
3. std::string name; 타입에 따라 암묵적인 초기화로 변수를 정의 
한 쌍의 중괄호 내부에 정의된 변수는 중괄호 내부의 코드를 실행할 동안에만 존재하는 지역변수이다 구현체가 }에 도달하면 구현체는
변수를 소멸시키고 변수가 차지하던 메모리를 시스템에 반환한다
const로 상수를 정의하면 소멸할떄까지 값을 바꾸지 않겠다는 의미이다 나중에 값을 못 바꾸기 때문에 정의하면서 초기화해야한다

입력 
std::cin >> v를 실행하면 표준 입력 스트림에 있는 모든 공백을 무시한 후 표준 입력의 내용을 변수 v에 넣는다
연속적인 입력 동작을 하려는 목적으로 istream타입인 std::cin을 반환한다 



</문자열사용>


<반복문과 카운팅>

while문은 주어진 조건이 참일 때 실행문을 반복하여 실행한다 형식은 다음과 같다
while(조건)
   실행문

실행문을 while문의 본문이라고도 한다 
while문은 조건을 판별하는 것으로 시작한다 조건이 거짓이면 본문을 전혀 실행하지 않는다 반면 조건이 참이면 본문을
한 번 실행한 후 다시 조건을 판별한다 while문은 조건이 거짓일 때까지 조건 판멸 및 본문 실행을 반복한다 
실행문은 실제로 실행문 하나이거나 하나의 블록(중괄호로 둘러싸인 0개 이상의 실행문)이다 

while문은 조건을 판별하는 것으로 시작하는데 조건은 진릿값을 반환하는 표현식이다 
r != rows일떄 비항동연산자인 !=를 사용하여 r과 rows를 비교한다 표현식의 결과는 bool타입이다 bool타입은 진릿값을 나타내는
기본 타입이다 bool타입은 참 또는 거짓 값을 갖는다 

++는 증가 연산자이고 변수값을 1만큼 증가시킨다 
++r 는 r = r+1과 동일하다 


while문을 작성하고 이해하는 데 유용한 두 가지 개념은 하나는 while문의 정의와 관련된 내용이고 다른 하나는 일반적인 프로그램의
동작에 관련된 내용이다 
첫번쨰 while문이 종료할 때는 반드시 조건은 거짓이어야 한다 
두번쨰 while문 내에서 항상 참인 루프 불변성이다 의도한대로 프로그램이 동작할 수 있게 불변성을 정해야 하고 적절할 때 불변성이
참이 되도록 프로그램을 작성해야 한다 불변성은 실제로 실행하는 코드가 아닌 주석 형태며 설계할 때 공을 들여야 하는 중요한 개념이다
해당 불변성에 논리적 오류가 없는지 확인하려면 while문에 조건을 판별할 때마다 불변성이 참인지 거짓인지확인해야 한다
즉 2개의 지점에서 불변성이 참인지 검증해야 하는데 
첫 번쨰 지점은 while문이 처음으로 조건을 판별하기 바로 전이고 두 번째 지점은 while문의 본문이 끝나기 바로 전이다 이 지점에서
불변성이 참이면 이후 조건을 판별할 때 불변성이 참이다 따라서 while문의 불변성은 항창 참이다 
반복문 본문의 역할은 적절한 변수를 조작하여 불변성이 참인 상태를 유지하여 결국 조건을 거짓으로 만드는 것이다

const std::string::size_type cols = greeting.size() + pad * 2 + 2;
여기서 const는 값이 변경되지 않도록 선언한다는 것이고 
std::string::size_type은 첫 번쨰 :: 은 범위 연산자이고 std::string은 std라는 네임스페이스에 속한 string이라는 기능을 의미한다
두 번쨰 ::은 string이라는 클래스에 속한 size_type이라는 기능을 사용하겠다는 것을 의미한다 네임스페이스나 블록과 마찬가지로
클래스는 자체적인 범위가 있다 std::string타입은 size_type을 문자열의 문자 개소를 보유하는데 적합한 타입으로 정의한다
문자열의 길이를 담는 지역 변수가 필요할 때마다 해당 변수의 타입으로 std::string::size_type을 사용해야 한다 

문자열의 길이는 음수가 될 수 없다 따라서 std::string::size_type은 부호 없는 타입이다 부호 없는 객체는 움스값을 포함할 수 없다 

if문은 조건이 참이면 if이후의 실행문을 실행하고 조건이 거짓이면 else이후의 실행문을 실행한다 

논리 연산자
(r == 0 || r == rows-1 || c == 0 || c== cols -1) 이 조건문에서 조건은 r이 0또는 rows -1이거나 c가 0이거나 cols-1이면 참이 된다 
C++프로그램은 == 기호를 사용해서 항동 여부를 판단한다 논리합 연산자인 ||는 피연산자 중 하나가 참이면 참을 반환한다
관계 연산자는 산술 연산자보다 우선순위가 낮다 둘 이상의 연산자를 포함한 표현식에서
우선순위는 피연산자를 나누는 방법을 정의한다 예를들어 r== rows -1 은 (r == rows) -1 이 아닌 r == (rows -1)을 의미한다 

||표현식은 bool값을 반환하며 조건 중 하나가 참이면 참을 반환한다 ||연산자는 관계 연산자보다 우선순위가 낮으며
대부분의 C++이진 연산자와 마찬가지로 왼쪽 우선 결합성이 있다 ||는 왼쪽 피연산자가 참일 떄 프로그램은 오른쪽의 피연산자의
진릿값을 전혀 구하지 않는데 이러한 속성을 간략 평가법이라고 한다 

여러 개 || 연산자로 구분하는 조건을 작성하면 프로그램은 각 조건을 차례대로 판별하도록 요청한다 하나라도 참이면 전체가 참이된다

&&은 논리곱 연산자이다 ||연산자처럼 두 조건을 판별하여 진릿값을 반환한다 또한 왼쪽 우선 결합성이 있으며 간략 평가법을 따른다 
&&연산자는 두 조건 중 하나라도 거짓이면 &&의 결과는 거짓이다 두 번쨰 조건은 첫 번째 조건이 참일때만 판별한다
복합할당연산자는 좌변과 우변을 더한 결과를 좌변에 넣는 과정을 줄여 쓴 것이다
ex) c+= geating.size;

std::의 반복 사용 줄이기
c++에서 특정 이름을 항상 네임스페이스에서 가져온 것이라고 해석하게 하는 방법이 있는데 다음과 같이 하면 된다
ex)  using std::cout;
이렇게 하면 cout라는 기능을 std::cout와 같은 의미로 사용할 수 있고 cout라는 이름은 갖는 무엇도 정의하지 않을것이라고 선언하는것이다
이러한 선언을 using 선언이라고 한다 usin선언한 이름은 다른 이름과 비슷하게 동작한다 예를들어 중괄호 안에서 선언하면
중괄호 끝날떄까지만 유요한다 


for문을 사용하면 while문과 다른 방법으로 반복문을 사용할 수 있다 사용은 다음과 같이 한다
ex) for(int r = 0; r != rows; ++r){  // r값을 변경하지 않는 부분 }
위 for문은 본문을 거칠 때마다 r은 0부터 rows -1 까지 연속된 값을 갖는다 0은 범위의 시작이고 rows는 범위의 마지막보다 하나 큰 값이된다
이러한 범위를 반 개방 범위라고 하며 '[시작 값, 마지막보다 하나 큰 값)'으로 표기한다 의도적으로 범위가 비대칭인걸 보여주려고 [와 )을
사용한다 

for문의 형태는 다음과 같다
for(초기실행문 조건; 표현식)
	실행문
첫 번쨰 행은 for헤더인데 for헤더는 실행문으로 이루어진 for본문을 제어한다 초기실행문은 정의문이거나 표현식이어야 한다
초기 실행문과 조건 사이에 세미콜론이 없는 것은 정의문 혹은 표현식과 같은 실행문이 자체적으로 세미콜론을 갖고 실행을 끝내기 떄문이다

for헤더의 초기실행문은 for문이 시작할 떄 한번만 실행한다 일반적으로 초기실행문은 조건의 일부인 반복 제어 변수를 정의하고 초기화한다
초기 실행문에서 정의한 변수는 for문 밖에서 소멸하므로 for문 이후의 코드에서는 접근할 수 없다

프로그램은 for문 반복 실행하면서 조건도 반복해서 판별한다 조건이 참을 반환하면 for문의 본문을 실행하고 그 이후에 헤더의 표현식을
실행한다 그런 다음 조건 판별을 반복하면서 조건이 거짓을 반환할 떄까지 본문과 헤더의 표현식을 계속해서 실행한다 

반복문을 이용할 떄 0부터 숫자를 셀 때는 비교 연산자로 !=를 사용하고 1부터 숫자를 셀 때는 비교 연산자로 <=를 사용해도
for문은 동일하게 돌아간다 하지만 대부분의 C++프로그래머는 0부터 시작하는것을 선호하는데 
숫자를 셀 때 0부터 시작하는 것은 변수의 변화 폭을 비대칭 범위로 표현할 수 있기 떄문이다 
[1, rows]를 범위로 사용하는 것보다 [0, rows)를 범위로 사용하는것이 더 자연스럽다
대칭보다 비대칭 범위를 사용하는 것이 일반적으로 더 쉬운 이유는 한 가지 주요 특성 떄문인다 [m.n)형태의 범위는 n-m개의 요소가 있고
[m,n]형태의 범위는 n-m +1개의 요소가 있다 [0,rows)는 요소 개수를 한눈에 알 수 있지만 [1,rows]는 상대적으로 그렇지 않다
숫자를 셀 떄 0부터 시작하는 또 다른 이유는 루프 불변성을 더 쉽게 표현할 수 있기 때문이다 0부터 시작하면 불변성을 지금까지 r개행
출력이라고 바로 표현할 수 있는데 1부터 숫자를 세면 r번째 행 출력이라는 문장은 불변성이 될 수 없다 
마지막 이유는 비교 연산자로 <=대신에 !=를 사용할 수 있기 때문이다 조건이 r!=rows라면 반복문이 끝났을 때 결과값은 r==rows가 된다 
 
표현식
C++는 C의 풍부한 연산자 집단을 그대로 사용할 수 있다 C++프로그램은 기본 연산자를 클래스 타입의 객체에 적용하는 것이 무엇을
의미하는지 정의하는 것으로 프로그래밍 언어의 기본 영역을 확장시킬 수 있다 복잡한 표현식을 정확하게 이해하는 것은 효과적인
C++프로그래밍의 기본 전제 조건이다 복잡한 표현식을 이해하려면 다음 사항을 이해해야 한다
- 표현식에 사용된 연산자의 우선순위와 연관성에 따라 피연산자를 구분하는 방법
- 피연산자를 다른 타입으로 변환하는 방법
-피연산자를 판별하는 순서 

연산자 각각은 우선순위가 다르다 할당 연산자, 조건연산자, 단일 인수가 있는 연산자는 오른쪽 우선 결합성을 지니며 이를
제외한 대부분 연산자는 왼쪽 우선 결합성을 지닌다
연산자의 우선순위 표는 다음과 같은데 높은 우선순위부터 낮은 우선순위 순이고 같은 우선순위 연산자 집단 그룹 사이는 두 줄 선으로 구분되어있다

연산자			설명
x.y			객체 x의 멤버 y
x[y]			객체 x에서 인덱스가 y인 요소
x++			x를 증가시키고 기존 x값을 반환
x--			x를 감소시키고 기존 x값을 반환
----------------------------------------------------------
++x			x를 증가시키고 증가된 값을 반환
--x			x를 감소시키고 감소된 값을 반환
!x			논리 부정이며 x가 참이면 !x는 거짓 
==========================================================
x*y 			x와 y의 곱
x/y			x를 y로 나눈 몫이며 두 피연산자가 모두 정수라면 결과도 정수 구현체가 0 또는 -무한대로 반올림할지 선택 
x%y			x를 y로 나눈 나미저이며 x - (( x/ y) * y)와 같다 x와 y는 반드시 정수여야 한다 
-------------------------------------------------------------
x+y 			x와 y의 합
x-y 			x에서 y를 뺸 결과
---------------------------------------------------------------
x>>y			정수 x,y에 한해서 x를 y비트만큼 오른쪽으로 이동(y는 음수가 아님) 만약 x가 istream이면 x에서 y로 읽어들임
x<<y			정수 x,y에 한해서 x를 y비트만큼 왼쪽으로 이동(y는 음수가 아님) 만약 x가 ostream이면 y를 x로 출력
================================================================
x relop y  		관계 연산자는 관계의 참과 거짓을 나타내는 bool타입을 반환 관계 연산자의 종류는 <, > , <= , >=
---------------------------------------------------------------
x == y 			x와 y가 같은지를 나타내는 bool 타입 값을 반환
x != y 			x와 y가 같지 않은지를 나타내는 bool 타입값을 반환
-----------------------------------------------------------
x && y 			x와 y가 모두 참인지 나타내는 bool 타입 값을 반환 x가 참일 떄만 y를 판별
=========================================================================================
x || y			x또는 y가 참인지를 나타내는 bool타입 값을 반환 x가 거짓일 떄만 y를 판별 
==========================================================================
x = y 			y값을 x에 할당하고 결과로 x를 반환 
x op= y 		복합 할당 연산자이며 x = x op y와 같다 op는 +,-,/,*,%,|,^,&,<<,>>중에 한가지이다 
x ? y : z 		x가 참이면 y 거짓이면 z를 반환 

표현식에서 피연산자를 판별하는 순서가 항상 같지는 않다 따라서 하나의 피연산자가 다른 피연산자의 값에 의존하는 단일
표현식 작성을 피하라는 규칙을 꼭 기억해야 한다 

피연산자는 변환할 수 있는 적절한 타입으로 변환된다 일반 표현식이나 관계 표현식에서 일반산술 변환에 따라 변환된다 
일반 산술 변환은 정밀도를 보존하는 쪽을 지향한다 작은 크기의 숫자 타입은 큰 숫자 타입으로 변환되고  부호가 있는 타입은
부호가 없는 타입으로 변환된다 산술값은 bool타입으로 변환될 수도 있다 0은 거짓 0이 아닌 값은 참으로 간주한다 
클래스 타입의 피연산자는 타입이 지정한대로 변환된다

타입
특별한 타입의 종류에는 다음과 같은 것들이 있다 
-bool : 참 또는 거짓 중 한 가지 진리값을 표현하는 기본 타입
-unsinged : 음수가 아닌 값을 포함하는 정수 타입
-short : 최소 16비트 정수 타입
-long : 최소 32bit 정수 타입
-size_t : 모든 객체의 크기를 저장할 수 있는 부호 없는 정수 타입<cdtddef>헤더에 정의됨
- string::size_type : 모든 문자열의 크기를 저장할 수 있는 부호 없는 정수 타입

반 개방 범위
하나의 종점을 포함하며 두 종점을 모두 포함하지는 않는다 예를들어 [1,3)범위는 1과 2를 포함하고 3은 포함하지 않는다 


조건 
진리값을 반환하는 표현식이다 조건에 사용된 산술값은 bool탕닙으로 변환된다 0이 아닌 값은 참 0은 거짓으로 변환된다 

실행문
실행문의 종류에는 다음과 같은 것들이 있다
- using 네임스페이스-이름::이름; : '네임스페이스-이름'의 동의어로 기능 이름을 정의한다 
- 타입-이름 이름 : 타입-이름 타입으로 기능 이름을 정의한다 
-타입-이름 이름 = 값  : '값'의 복사본으로 초기화된 '타입-이름'타입의 이름을 정의한다 
-타입-이름(인수) : 주어진 인수에 적합하게 생성된 타입-이름 타입의 기능 이름을 정의
-표현식;  : 부수적으로 발생하는 결과로 표현식을 실행한다
-{실행문} : 블록을 호출한다 0개 이상의 연속된 실행문을 순서대로 실행한다 실행문이 오는 곳 어디서나 사용할 수 있다
중괄호 내부에 정의된 변수 범위는 블록 안으로 제한된다
-while(조건) 실행문 : '조건'이 거짓이면 아무것도 안하고 참이면 실행문을 반복한다 
- for(초기-실행문 조건 ; 표현식 ) 실행문 : 실행문이 continue문이거나 continue문을 포함하지 않는 한 조건이 참이면 반복한다
-if(조건) 실행문 : 조건이 참이면 실행문을 실행한다 
-if(조건) 실행문 else 실행문2 : 조건이 참이면 실행문 실행 거짓이면 실행문2를 실행 각 else문은 가장 가까운if문과 짝을 이룬다
-return 값; : 함수를 빠져나오면서 함수를 호출한 지점으로 값을 반환한다 



</반복문과 카운팅>


<데이터 일괄 처리>

#include <ios>는 입출력 라이브러리에서 전송된 문자 수나 버퍼 크기를 나타내려고 사용하는 타입인 streamsize를 정의한다
#include <iomaip>는 출력 결과의 유효 자리수를 결정하는 조작어인 setprecision을 정의한다 
보통 사용자에게 입력을 받을 때 EOF신호를 만날떄까지 계속 값을 입력받는다 다양한 C++
구현체들은 각자 방식으로 프로그램에 EOF신호를 보낸다 가장 일반적인 방식은 새로운
행을 입력하는 것인데 ctrl + z(마이크로소프트 윈도우) , ctrl + d(유닉스 또는 리눅스)를 입력하면 된다

부동 소수점을 나타내는 타입으로 float(32비트)와 double(64비트)가 있는데 소수점 계산 대부분은
float보다는 double을 사용하는 것이 낫다 
float는 정밀도가 6자리(10진수)정도인데 double타입은 최소 10자리의 유효한 자리를
나타낼 수 있다 그리고 모든 구현체는 15자리까지 유효 자리를 표현할 수 있다 최근 컴퓨팅
환경에서는 일반적으로 double이 float보다 훨신 빠르다 연산속도도 큰 차이가 없다

사용자에게 입력을 받을 때 2개 이상의 경우 공백으로 분리된 2개 이상의 문자열은 자동으로 
결합되기 때문에 
cin >> a >> b;  =   cin >> a;  cin>> b; 이런식으로 입력을 받아도 상관이 없다 

double을 초기값이 있는 상태로 선언할 때 int값인 0을 넣어도 구현체가 컴파일 중에 변환을
실행하므로 오버헤드가 발생하지 않는다
ex) double a = 0;

변수의 초기값을 지정하지 않으면 암묵적으로 기본 초기화 단계를 따르고 이러한 초기화는
변수 타입에 따라 결과가 다르다 클래스 타입인 객체를 따로 초기화하지 않으면 
클래스 자체에서 정한 초기화 방식을 따른다 

명시적으로 초기화하지 않은 기본 타입 지역 변수는 정의하지 않은상태이다 이때 변수는
생성된 메모리 공간을 이미 차지하는 임의의 의미 없는 값이된다 또한 유효값을 덮어쓰는 것
이외에 다른 방법으로 정의하지 않은 값을 다룰 수는 없다 대부분 구현체는 이러한 규칙을 어겨도
정의하지 않은 값에 접근을 허용한다 하지만 메모리에 있는 값은 정확한 값이 아니여서
충돌이 일어나거나 잘못된 결과를 얻게된다 

while문의 조건으로 데이터 입력을 받으면 입력이 발생하는 한 계속 실행된다
ex) while(std::cin >> x)
istream클래스에서는 cin을 숫자 값으로 바꿀 수 있고 해당 숫자 값을 bool타입값으로 바꿔
조건을 판별할 수 있다 값을 바꿔 반환하는 값은 최근에 입력을 받았는지에 따라 달라지는
istream객체의 내부 상태를 반영한다 따라서 조건 판별에서 cin을 사용하는것은 cin을 이용해
최근에 입력을 받았는지 판별하는 것과 같은데 입력값을 읽을 수 없는 상황은
-EOF에 도달했을 떄
-변수의 타입과 맞지 않는 값을 받았을 때
-시스템이 입력 장치에서 하드웨어 장애를 감지했을 때이다 
이와 같은 상태의 입력 스트림을 조건 판별에 사용하면 조건은 거짓이 된다 

setprecision은 endl과 마찬가지로 조작어인데 이어서 발생하는 출력을 주어진 숫자만큼의
유효 자릿수로 나타내려고 스트림을 조작한다 setprecision(3)이라고 하면 3개의 유효
자릿수로 출력하도록 구현체에 요청하라는 의미이다 

cout의 멤버 함수인 precision을 호출하면 스트림이 부동 소수점 표현에 사용하는 정밀도를 알려준다 
setprecision으로 정밀도를 바꿨을 때 출력 후 precision함수가 알려준 값으로 정밀도를
다시 바꾸기 위해 사용한다 
precision을 이용해 정밀도를 바꿀 수도 있다
ex) streamsize prec = cout.precision(3) 정밀도를 3으로 바꾸고 바꾸지 전의 정밀도를 반환

표준 라이브러리는 벡터 타입을 제공하는데 벡터는 값의 집단이 있는 컨테이너이다 
각 벡터의 값은 모두 같은 타입이며 벡터를 정의할 때마다 벡터가 담을 값의 타입을 지정행한다 
벡터 타입은 C++의 특징인 템플릿 클래스로 정의한다 객체의 타입은 꺽쇠괄호를 사용해 지정한다
예를들어 vector<double>타입의 객체는 double타입의 객체를 담은 벡터고
vector<string>타입의 객체는 문자열을 담은 벡터이다 
벡터는 주어진 타입 값들의 순차열이 있으며
새로운 값을 저장할 필요에 따라 늘어난다 그리고 개별 값에 효율적으로 접근할 수 있다 
벡터사용은 다음과 같이 한다
ex) vector<double> homework;  homework.push_back(x)
여기서 push_back은 멤버 함수이다 push_back은 벡터의 마지막에 새 요소를 추가하는 작업을 실행한다
이때 발생하는 부수적인 효과 때문에 벡터의 크기는 1 증가한다 

벡터 타입은 vector<타입>::size_type이라는 타입과 size라는 함수를 정의한다 
size_type은 크기가 큰 벡터도 충분이 담을 수 있는 부호 없는 타입이고 size()는 베터요소의
개수를 나타내는 size_type값을 반환한다 
벡터의 모든 요소는 인덱스라는 정수값이 있는데 예를들어homework[mid]는 인덱스가 mid인
벡터 homework의 요소이다 벡터의 첫 번쨰 요소는 벡터[0]이고 마지막 요소는 벡터[size-1]이다

타입의 이름이 길어서 사용이 불편한 경우 typedef라는 언어 기능을 사용하여 변수를 정의할 때
변수 타입의 동의어로 이름을 지정할 수 있다
ex) typedef vector<double>::size_type vec_sz;

<algorithm>헤더에서 정의하는 sort함수를 사용하여 값들을 정렬할 수 있다 
sort의 인수로는 정렬할 요소의 범위를 지정한다 벡터를 정렬할 때
ex) sort(homework.begin(), homework.end()); 이렇게 사용할 수 있다
벡터.begin()은 벡터의 첫 번쨰 요소를 의미하고 벡터.end()는 벡테의 마지막 요소를 의미한다 
sort함수는 정렬한 결과를 담으려고 새 컨테이너를 만들지 않고 컨테이너 요소 값들을 이동하여 정렬한다 

c++표준은 라이브러리 구현시 성능에 관한 요구 사항이 있으므로 프로그램의 성능을 화신할
수 있다 라이브러리는 이러한 요구 사항에 따라 동작에 관한 설계 명세와 정확한 목표 성능을
만족시켜야 한다 표준을 준수하는 모든 C++구현체는 다음사항을 지켜야한다
-벡터에 많은 개수의 요소를 추가할 떄 성능이 요소 개수에 비례하여 나빠지지 않게 벡터를 구현해야 한다
- sort함수의 성능이 nlong(n)보다 느려지지 않도록 구현해야 한다 

유용한 라이브러리 기능
sort(b,e) :   [b,e)범위에 정의된 요소들을 오름차순으로 다시 정렬한다 <algorithm>헤더에 정의되어있다
max(e1,e2) : e1과 e2중에 더 큰것을 반환한다 e1과 e2는 정확히 같은 타입이어야 한다 <algorithm>헤더에 정의되어있다
while(cin>>x) : x에 적절한 타입의 값을 읽어들여 스트림의 상태를 판별한다 스트림이 오류상태면
while의 조건은 거짓이고 그렇지않으면 while문의 본문이 실행된다 



</데이터 일괄 처리>